import{f as d,a}from"../chunks/B4CENAi2.js";import"../chunks/Cb5RJ986.js";import{$ as i,a3 as v,_ as h,a4 as g,a5 as f,a6 as s,a1 as r,a2 as o}from"../chunks/nTiiik5H.js";import{h as b}from"../chunks/BRWPMuHm.js";import{s as n}from"../chunks/CD6AqAwx.js";import{b as c}from"../chunks/BLegY4ON.js";const T=!0,S=Object.freeze(Object.defineProperty({__proto__:null,prerender:T},Symbol.toStringTag,{value:"Module"}));var x=d('<meta name="description" content="No libraries, no regex hell — how pure TypeScript and smart lookups deliver blazing-fast HTML entity encoding even on massive text."/> <meta property="og:title" content="Real-Time Encoding at 50,000 Characters: &lt;10ms | AxelBase Blog"/> <meta property="og:description" content="No libraries, no regex hell — how pure TypeScript and smart lookups deliver blazing-fast HTML entity encoding even on massive text."/> <meta property="og:url"/> <meta property="og:type" content="article"/> <meta name="twitter:card" content="summary_large_image"/>',1),_=d('<div class="container fade-in post-layout svelte-led0iy"><div class="breadcrumbs svelte-led0iy"><a class="svelte-led0iy">Blog</a> <span>/</span> <p>Real-Time Encoding at 50,000 Characters</p></div> <article class="prose svelte-led0iy"><h1 class="svelte-led0iy">Real-Time Encoding at 50,000 Characters: How We Achieved &lt;10ms</h1> <p class="post-meta svelte-led0iy">Published: November 18, 2025</p> <p>You just pasted a 48 KB log file into the input. The output updates instantly. No freeze. No “processing” spinner. How?</p> <p>Most online encoders use slow regular expressions or bloated libraries. We don’t. The AxelBase encoder is built from the ground up for raw speed and zero dependencies.</p> <h2 class="svelte-led0iy">The Secret Sauce</h2> <ul class="svelte-led0iy"><li class="svelte-led0iy">One single character-by-character loop — no repeated regex scans</li> <li class="svelte-led0iy">Pre-built Map of all 2,000+ HTML5 named entities (fast lookup)</li> <li class="svelte-led0iy">Direct charCodeAt() → hex conversion with a tiny lookup table</li> <li class="svelte-led0iy">No DOM manipulation during conversion</li> <li class="svelte-led0iy">Zero garbage collection pressure</li></ul> <h2 class="svelte-led0iy">Benchmark Results (Chrome 129)</h2> <p>50,000 characters of mixed English + French + math symbols:</p> <ul class="svelte-led0iy"><li class="svelte-led0iy">AxelBase encoder: 4–8 ms</li> <li class="svelte-led0iy">he library (popular on npm): 68 ms</li> <li class="svelte-led0iy">DOMPurify + innerHTML trick: 180+ ms</li></ul> <h2 class="svelte-led0iy">Why This Matters</h2> <p>When you’re cleaning up a huge CMS export, debugging a broken template, or writing a linter, you don’t want to wait. Instant feedback is the difference between a tool you use once and a tool you use every day.</p> <h2 class="svelte-led0iy">FAQ</h2> <details class="svelte-led0iy"><summary class="svelte-led0iy">Why not use TextEncoder?</summary> <p class="svelte-led0iy">TextEncoder is for UTF-8 bytes, not HTML entities. It can’t help here.</p></details> <details class="svelte-led0iy"><summary class="svelte-led0iy">Is it safe to run on untrusted input?</summary> <p class="svelte-led0iy">Yes. The algorithm never executes code — it only reads and writes strings.</p></details> <p class="italic-note svelte-led0iy">Speed isn’t a luxury in developer tools — it’s table stakes.</p></article></div>');function C(p){var e=_();b("led0iy",u=>{var l=x(),y=v(h(l),6);s(4),i(()=>n(y,"content",`${c??""}/blog/posts/post4`)),g(()=>{f.title="Real-Time Encoding at 50,000 Characters: How We Achieved 10ms | AxelBase Blog"}),a(u,l)});var t=r(e),m=r(t);s(4),o(t),s(2),o(e),i(()=>n(m,"href",`${c??""}/blog`)),a(p,e)}export{C as component,S as universal};
